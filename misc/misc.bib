%% This BibTeX bibliography file was created using BibDesk.
%% http://bibdesk.sourceforge.net/


%% Created for ??????? ??????? at 2006-05-28 23:53:31 +0300 


%% Saved with string encoding Western (ASCII) 



@article{Marco05,
	Address = {New York, NY, USA},
	Author = {Esperanza Marcos},
	Date-Added = {2006-05-25 23:19:04 +0300},
	Date-Modified = {2006-05-25 23:50:29 +0300},
	Doi = {http://doi.acm.org/10.1145/1082983.1083005},
	Issn = {0163-5948},
	Journal = {SIGSOFT Softw. Eng. Notes},
	Local-Url = {file://localhost/Volumes/Files/Documents/PhD/papers/Misc/Software%20engineering%20research%20versus%20software%20development.pdf},
	Number = {4},
	Pages = {1--7},
	Publisher = {ACM Press},
	Title = {Software engineering research versus software development},
	Volume = {30},
	Year = {2005}}

@inproceedings{Dodig02,
	Address = {Sk{\"{o}}vde},
	Author = {Gordana Dodig-Crnkovic},
	Booktitle = {Conference for the Promotion of Research in IT at New Universities and at University Colleges in Sweden},
	Date-Added = {2006-05-25 14:59:08 +0300},
	Date-Modified = {2006-05-25 14:59:11 +0300},
	Month = {April},
	Title = {Scientific Methods in Computer Science},
	Url = {http://www.mrtc.mdh.se/index.phtml?choice=publications&id=0446},
	Year = {2002}}

@phdthesis{Wrigh01,
	Author = {G.M. Wright},
	Date-Added = {2006-05-25 11:47:45 +0300},
	Date-Modified = {2006-05-25 11:48:20 +0300},
	Month = {January},
	School = {University of Manchester},
	Title = {A Single-Chip Multiprocessor Architecture with Hardware Thread Support},
	Year = {2001}}

@misc{Machi98,
	Address = {http://www.acm.org/class/1998/overview.html},
	Date-Added = {2006-05-23 23:41:39 +0300},
	Date-Modified = {2006-05-28 23:52:24 +0300},
	Howpublished = {Online},
	Organization = {Association For Computing Machinery},
	Title = {{ACM} Computing Classification System},
	Url = {http://www.acm.org/class/1998/overview.html},
	Year = {1998}}

@article{Peter83,
	Abstract = {The problem of asynchronous processes reading shared data while the data are being modified by another process is considered. This problem differs from the standard readers/writers problem in that concurrent reading while writing is allowed. The model used here strongly limits the use and size of the shared variables. If multiple copies of the shared data are allowed, then simple, efficient solutions are found. In general, solutions which are more time efficient because they avoid waiting are seen to require more copies of the shared data. The number of copies used by all algorithms is shown to be the best possible. The main solution demonstrates that any system of processes which uses large distributed variables can be strongly simulated by a system which uses only binary distributed variables.},
	Annote = {The basics of the copy on write technique},
	Author = {Gary L. Peterson},
	Date-Added = {2006-02-13 15:58:19 +0200},
	Date-Modified = {2006-02-13 16:01:10 +0200},
	Doi = {http://doi.acm.org/10.1145/357195.357198},
	Journal = {ACM Trans. Program. Lang. Syst.},
	Local-Url = {file://localhost/Volumes/Files/Documents/PhD/papers/Misc/Concurrent%20Reading%20While%20Writing.pdf},
	Number = {1},
	Pages = {46--55},
	Title = {Concurrent Reading While Writing},
	Volume = {5},
	Year = {1983}}

@techreport{Herma47,
	Address = {Princeton, N. J},
	Author = {Goldstine Herman and John von Neumann},
	Date-Added = {2006-01-09 14:11:28 +0200},
	Date-Modified = {2006-01-09 14:15:18 +0200},
	Institution = {Inst. for Advanced Study},
	Number = {Vol. 1--3},
	Title = {Planning and coding of problems for an electronic computing instrument},
	Year = {1947}}

@techreport{ISO/I05,
	Author = {ISO/IEC 9899:TC/2},
	Date-Added = {2005-11-29 13:13:52 +0200},
	Date-Modified = {2005-11-29 13:18:59 +0200},
	Institution = {ISO/IEC},
	Title = {Programming Languages - {C}},
	Type = {Committee Draft},
	Year = {2005}}

@article{Henne82,
	Abstract = {The long-standing conflict between code optimization and symbolic debugging is examined. The  effects of local and global optimizations on the variables of a program are categorized, and models for  representing  the effect of optimizations are given. Algorithms use these models to determine the  subset of variables whose values do not correspond to those in the original program. Restoring these  variables to their correct values is investigated, and empirical results from the application of these  algorithms to local optimization are also presented. },
	Author = {John Hennessy},
	Date-Modified = {2005-03-03 12:41:19 +0200},
	Doi = {http://doi.acm.org/10.1145/357172.357173},
	Issn = {0164-0925},
	Journal = {ACM Trans. Program. Lang. Syst.},
	Local-Url = {file://localhost/Volumes/Files/Documents/PhD/papers/Misc/Symbolic%20Debugging%20of%20Optimized%20Code.pdf},
	Number = {3},
	Pages = {323--344},
	Publisher = {ACM Press},
	Title = {Symbolic Debugging of Optimized Code},
	Volume = {4},
	Year = {1982}}

@misc{wiki,
	Date-Modified = {2005-03-29 09:49:36 +0300},
	Howpublished = {Online},
	Key = {WikiPedia},
	Note = {http://en.wikipedia.org/wiki/Main\_Page},
	Title = {{WikiPedia}, the free encyclopedia},
	Year = {2005}}

@article{Hanki96,
	Annote = {An article that describes what the future directions on programming language design should be, according to an expert comitee meeting in 1996. Interesting directions:
Implementation -> Memory management: Cache efficient garbage collection
Type systems -> Type-based compilation: Typed program analysis to exploit possible optimisations},
	Author = {Chris Hankin and Hanne Riis Nielson and Jens Palsberg},
	Date-Modified = {2005-03-07 14:06:05 +0200},
	Doi = {http://doi.acm.org/10.1145/242223.242260},
	Issn = {0360-0300},
	Journal = {ACM Comput. Surv.},
	Local-Url = {file://localhost/Volumes/Files/Documents/PhD/papers/Misc/Strategic%20directions%20in%20research%20on%20programming%20languages.pdf},
	Number = {4},
	Pages = {644--652},
	Publisher = {ACM Press},
	Title = {Strategic directions in research on programming languages},
	Volume = {28},
	Year = {1996}}

@article{Ferra87,
	Abstract = {In this paper we present an intermediate program representation, called the program dependence graph (PDG), that makes explicit both the data and control dependences for each operation in a program. Data dependences have been used to represent only the relevant data flow relationships of a program. Control dependences are introduced to analogously represent only the essential control flow relationships of a program. Control dependences are derived from the usual control flow graph. Many traditional optimizations operate more efficiently on the PDG. Since dependences in the PDG connect computationally related parts of the program, a single walk of these dependences is sufficient to perform many optimizations. The PDG allows transformations such as vectorization, that previously required special treatment of control dependence, to be performed in a manner that is uniform for both control and data dependences. Program transformations that require interaction of the two dependence types can also be easily handled with our representation. As an example, an incremental approach to modifying data dependences resulting from branch deletion or loop unrolling is introduced. The PDG supports incremental optimization, permitting transformations to be triggered by one another and applied only to affected dependences.},
	Author = {Jeanne Ferrante and Karl J. Ottenstein and Joe D. Warren},
	Date-Modified = {2005-03-03 14:28:43 +0200},
	Doi = {http://doi.acm.org/10.1145/24039.24041},
	Issn = {0164-0925},
	Journal = {ACM Trans. Program. Lang. Syst.},
	Local-Url = {file://localhost/Volumes/Files/Documents/PhD/papers/Misc/The%20program%20dependence%20graph%20and%20its%20use%20in%20optimization.pdf},
	Number = {3},
	Pages = {319--349},
	Publisher = {ACM Press},
	Title = {The program dependence graph and its use in optimization},
	Volume = {9},
	Year = {1987}}

@article{Steen89,
	Abstract = {Register allocation is an important optimization in many compilers, but with per-procedure register allocation, it is often not possible to make good use of a large register set. Procedure calls limit the improvement from global register allocation, since they force variables allocated to registers to be saved and restored. This limitation is more pronounced in LISP programs due to the higher frequency of procedure calls. An interprocedural register allocation algorithm is developed by simplifying a version of interprocedural graph coloring. The simplification corresponds to a bottom-up coloring of the interference graph. The scheme is evaluated using a number of LISP programs. The evaluation considers the scheme's limitations and compares these ``software register windows'' against the hardware register windows used in the Berkeley RISC and SPUR processors.},
	Author = {Peter A. Steenkiste and John L. Hennessy},
	Date-Modified = {2005-03-03 14:38:33 +0200},
	Doi = {http://doi.acm.org/10.1145/59287.59289},
	Issn = {0164-0925},
	Journal = {ACM Trans. Program. Lang. Syst.},
	Local-Url = {file://localhost/Volumes/Files/Documents/PhD/papers/Misc/A%20simple%20interprocedural%20register%20allocation%20algorithm%20and%20its%20effectiveness%20for%20LISP.pdf},
	Number = {1},
	Pages = {1--32},
	Publisher = {ACM Press},
	Title = {A simple interprocedural register allocation algorithm and its effectiveness for LISP},
	Volume = {11},
	Year = {1989}}

@article{Aho89,
	Abstract = {Compiler-component generators, such as lexical analyzer generators and parser generators, have long been used to facilitate the construction of compilers. A tree-manipulation language called twig has been developed to help construct efficient code generators. Twig transforms a tree-translation scheme into a code generator that combines a fast top-down tree-pattern matching algorithm with dynamic programming. Twig has been used to specify and construct code generators for several experimental compilers targeted for different machines.},
	Author = {Alfred V. Aho and Mahadevan Ganapathi and Steven W. K. Tjiang},
	Date-Modified = {2005-03-03 14:45:03 +0200},
	Doi = {http://doi.acm.org/10.1145/69558.75700},
	Issn = {0164-0925},
	Journal = {ACM Trans. Program. Lang. Syst.},
	Local-Url = {file://localhost/Volumes/Files/Documents/PhD/papers/Misc/Code%20generation%20using%20tree%20matching%20and%20dynamic%20programming.pdf},
	Number = {4},
	Pages = {491--516},
	Publisher = {ACM Press},
	Title = {Code generation using tree matching and dynamic programming},
	Volume = {11},
	Year = {1989}}

@article{Lampo82,
	Abstract = {Reliable computer systems must handle malfunctioning components that give conflicting information  to different parts of the system. This situation can be expressed abstractly in terms of a group of  generals of the Byzantine army camped with their troops around an enemy city. Communicating only  by messenger, the generals must agree upon a common battle plan. However, one or more of them  may be traitors who will try to confuse the others. The problem is to find an algorithm to ensure that  the loyal generals will reach agreement.  It is shown that, using only oral messages, this problem is  solvable if and only if more than two-thirds of the generals are loyal; so a single traitor can confound  two loyal generals. With unforgeable written messages, the problem is solvable for any number of  generals and possible traitors.  Applications of the solutions to reliable computer systems are then  discussed.  },
	Author = {Leslie Lamport and Robert Shostak and Marshall Pease},
	Date-Modified = {2005-03-03 12:43:33 +0200},
	Doi = {http://doi.acm.org/10.1145/357172.357176},
	Issn = {0164-0925},
	Journal = {ACM Trans. Program. Lang. Syst.},
	Local-Url = {file://localhost/Volumes/Files/Documents/PhD/papers/Misc/The%20Byzantine%20Generals%20Problem.pdf},
	Number = {3},
	Pages = {382--401},
	Publisher = {ACM Press},
	Title = {The Byzantine Generals Problem},
	Volume = {4},
	Year = {1982}}

@article{Chand84,
	Abstract = {The problem of resolving conflicts between processes in distributed systems is of practical importance.  A conflict between a set of processes must be resolved in favor of some (usually one) process and  against the others: a favored process must have some property that distinguishes it from others. To  guarantee fairness, the distinguishing property must be such that the process selected for favorable  treatment is not always the same. A distributed implementation of an acyclic precedence graph, in  which the depth of a  process (the longest chain of predecessors)  is a  distinguishing property, is  presented. A simple conflict resolution rule coupled with the acyclic graph ensures fair resolution of  all conflicts. To make the problem concrete, two paradigms are presented: the well-known distributed  dining philosophers problem and a generalization of it, the distributed drinking philosophers problem.},
	Author = {K. M. Chandy and J. Misra},
	Date-Modified = {2005-03-03 13:28:47 +0200},
	Doi = {http://doi.acm.org/10.1145/1780.1804},
	Issn = {0164-0925},
	Journal = {ACM Trans. Program. Lang. Syst.},
	Number = {4},
	Pages = {632--646},
	Publisher = {ACM Press},
	Title = {The drinking philosophers problem},
	Volume = {6},
	Year = {1984}}

@article{Tichy86,
	Abstract = {With current compiler technology, changing a single line in a large software system may trigger massive recompilations. If the change occurs in a file with shared declarations, all compilation units depending upon that file must be recompiled to assure consistency. However, many of those recompilations may be redundant, because the change may affect only a small fraction of the overall system. Smart recompilation is a method for reducing the set of modules that must be recompiled after a change. The method determines whether recompilation is necessary by isolating the differences among program modules and analyzing the effect of changes. The method is applicable to languages with and without overloading. A prototype demonstrates that the method is efficient and can be added with modest effort to existing compilers.  },
	Author = {Walter F. Tichy},
	Date-Modified = {2005-03-03 14:20:00 +0200},
	Doi = {http://doi.acm.org/10.1145/5956.5959},
	Issn = {0164-0925},
	Journal = {ACM Trans. Program. Lang. Syst.},
	Local-Url = {file://localhost/Volumes/Files/Documents/PhD/papers/Misc/Smart%20Recompilation.pdf},
	Number = {3},
	Pages = {273--291},
	Publisher = {ACM Press},
	Title = {Smart recompilation},
	Volume = {8},
	Year = {1986}}
